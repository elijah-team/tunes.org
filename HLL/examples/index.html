<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <HEAD>
    <!--#include virtual="/head.html" -->
    <TITLE>HLL Examples</TITLE>
  </HEAD>
  <BODY>
    <H1>HLL examples</H1>
    <!--#include virtual="header.html" -->
    <p>How our HLL is superior to any other language.</p>
    <h2>Generic algorithms:</h2>
    <ul>
      <li>The <A HREF="sieve.html">Sieve of Eratosthene</A>.</li>
    </ul>
<h2>Proposed example categories:</h2>
    <UL>
      <LI>programming with active annotations (including powerful parsing)</li>
      <LI>self-extending the language (including mixing syntaxes)</li>
      <LI>implicit programming (including logical programming)</li>
      <LI>program proofs (including strong typing)</li>
      <LI>Incremental programming with annotations (including incremental proofs).</li>
      <LI>optimization through annotations (including using assembly)</li>
      <LI>customizing programs (including UI interface)</li>
      <LI>isolating modules (including securing objects)</li>
    </UL>

<h2>Various aspects of the HLL as a truly all-purpose language:</h2>
    <p>Presenting the HLL as:</p>
    <dl>
      <dt>An interactive shell (including using a graphical or voice interface)</dt>
      <dd>Elements:
	<ul>
	  <li>Easy access to job control.</li>
	  <li>Easy access to composing and adapting small simple components into a program.</li>
	  <li>Terse, clear syntax.</li>
	</ul></dd>
      <dt>A scripting language (including event programming)</dt>
      <dd>Properties:
	<ul>
	  <li>Unambiguous syntax that makes completion and context-discovery trivial.</li>
	  <li>Verb-Object and Object-Verb grammatical ordering.</li>
	  <li>Easy embedding of domain-specific languages.</li>
	</ul></dd>
      <dt>A structural editor (including WYSIWYG text processing)</dt>
      <dd>Elements:
	<ul>
	  <li>A quasi-quotation mechanism as in Scribe Scheme's bracket syntax, so that it can be unquoted.</li>
	  <li>A level of translation possible that is non-trivial (not just macro-expansion in other words).</li>
	  <li>Mechanisms for extending this system for a domain-specific use.</li>
	  <li>Mechanisms for <em>limiting</em> the grammar for domain-specific safety and encoding efficiency.</li>
	</ul></dd>
      <dt>A database language (including 4GL queries)</dt>
      <dd>Elements:
	<ul>
	  <li>A boolean and relational query language for the information stores and the query language's abstractions as well.</li>
	  <li>A equational constraint system and a strategizer for solving it dynamically, so that invariants can be specified in a way that relates to a common school-taught concept, while being logically sound.</li>
	</ul></dd>
      <dt>A basis for natural language interfaces (including knowledge databases)</dt>
    </dl>

<h2>Real-Life examples:</h2>
    <UL>
      <LI>Writing a generic version of the Ziv-Lempel compression algorithm, and used to independently specialize the encoding (to code/decode LZ77, LZH, LZW, GIF and other formats) and tune the implementation (optimizing encode table caching)</li>
    </UL>

<H2>To Do</H2>
    <ul>
      <LI>Fill out examples.</li>
      <LI>Find all kind of programming paradigms to illustrate.</li>
      <LI>Find examples from all other languages.</li>
      <LI>Show our way to meta-self-extend so as to better any other language.</li>
      <LI>Show use of the standard libraries.</li>
      <LI>Show standard interfaces to the hardware.</li>
      <LI>See also <a href="http://www.willamette.edu/~fruehr/haskell/evolution.html">The Evolution of a Haskell Programmer</a>.</li>
    </ul>
    <!--#include virtual="/footer.html" -->
  </body>
</html>
