<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!--#include virtual="/head.html" -->
    <title>Tunes HLL Semantic Primitives</title>
  </head>
  <body>
    <h1>Tunes HLL Semantic Primitives</h1>
    <!--#include file="header.html" -->
    <p>The HLL provides a set of basic constructors. This set should enable it to emulate any kind of other set of constructors. <span class="comment"><em>Editor's Note:</em> we need more reasons than just this to pick a set of pseudo-primitives.</span></p>

<h2>Applying Functions</h2>
    <ul>
      <li>As in <a href="/tunes.org/cliki.tunes.org/Self">Self</a> or <a href="/tunes.org/cliki.tunes.org/Lisp">Lisp</a>, the basic constructor will be applying an attribute/function to an object.</li>
      <li>As in <a href="/tunes.org/cliki.tunes.org/Scheme">Scheme</a> or <a href="/tunes.org/cliki.tunes.org/ML">ML</a>, and unlike Self or Lisp, the attribute/function is not a <a href="/tunes.org/cliki.tunes.org/Meta-Level">meta-level</a> symbol, but a zero-level (first-class) object. In other words, functions will be used and bound according to the same protocols as ordinary objects.</li>
    </ul>

<h2>Abstracting terms</h2>
    <p>The next basic constructor is typed <a href="/tunes.org/cliki.tunes.org/Abstraction">abstraction</a> on any sub-object of an expression, using any <a href="/tunes.org/cliki.tunes.org/Type System">type system</a>, which allows the creation of new functions, i.e. lambda-expressions, from an arbitrarily (but strongly) typed lambda calculus, which gives something like:<br>
      <code>lambda (x).sin(2*x+1)</code><br>
      <code>method (x) ; sin(2*x+1) ; end method ;</code> (using <a href="/tunes.org/cliki.tunes.org/Dylan">Dylan</a> syntax)<br>
      <code>fun x -&gt; sin(2. *. x +. 1.)</code> (using <a href="/tunes.org/cliki.tunes.org/OCAML">OCAML</a> syntax)<br>
      <code>[x:Real] sin(2.0 *. x +. 1.0)</code> (using <a href="/tunes.org/cliki.tunes.org/Coq">Coq</a> syntax)<br>
    </p>

<h2>Defining typed constructors</h2>
    <ul>
      <li>You can define typed constructor axioms; but they won't be trusted unless <em>you</em> are trusted too; that is, trusting the axiom creator is part of any proof.
	<p>For example, if you have access to the type of terms for programs and data, then you can use standard "compilers" that construct objects from tools; among them are creations of inductive definitions and such or (if you're trusted enough in the context), you can associate low-level objects to a high-level specification without a proof.</p>
      </li>
      <li>Standard constructors (including all the previous) can be selectively trusted, so that contexts can be very limited (e.g. only applying functions among those from a list), or very open (trusting all the inherently secure constructors plus a list of axioms/trustees)</li>
      <li>Inductive definitions (as in <a href="/tunes.org/cliki.tunes.org/Coq">Coq</a>) may be used as a secure way to construct new types.</li>
    </ul>

<h2>Evaluation strategy</h2>
    <ul>
      <li>Objects can be future or actual; you can explicitly force or delay objects, or do it implicitly by just annotating a function object to say that its argument may be future, or should be actual.</li>
      <li>Functions can be pure or impure (without or with side-effects); in the latter case, specifications may include how impure the function is.</li>
    </ul>
    <!--#include virtual="/footer.html" -->
  </body>
</html>
