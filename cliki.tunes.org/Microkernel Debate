<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app227.us.archive.org';v.server_ms=311;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="/_static/js/bundle-playback.js?v=MzYkZ0TU" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=UHAOicsW" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://cliki.tunes.org:80/Microkernel%20Debate","20050307161303","https://web.archive.org/","web","/_static/",
	      "1110211983");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=S1zqJCYt" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->
<title>CTO : Microkernel Debate</title><link rel="alternate" type="application/rss+xml" title="Recent Changes" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/recent-changes.rdf"><link rel="stylesheet" href="https://web.archive.org/web/20050307161303cs_/http://cliki.tunes.org/admin/cliki.css"></head><body><div id="banner"><a title="CTO" class="logo" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/">CTO</a> <span>CLiki for the TUNES project</span></div><div id="navbar"><a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/index">Home</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Recent%20Changes">Recent Changes</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/CLiki">About CLiki</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Text%20Formatting">Text Formatting</a> <a class="internal" onclick="if(name=window.prompt('New page name ([A-Za-z0-9 ])')) document.location='https://web.archive.org/web/20050307161303/http://cliki.tunes.org/edit/'+name ;return false;" href="/web/20050307161303/http://cliki.tunes.org/">Create New Page</a></div><div id="main"><h1>Microkernel Debate</h1>This is a debate on <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microkernel">Microkernel</a>s. It begins with the original TUNES Glossary entry on <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microkernel">Microkernel</a> as written by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Far%E9">Faré</a>. Follows a response by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/KC5TJA">KC5TJA</a>, prompted by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/thin">thin</a>. An answering to this response was added as bracketed comments by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>.

<p><h2>Microkernels</h2>
(original TUNES Glossary entry by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Far%E9">Faré</a>)

<p>Microkernel (also abbreviated µK or uK) is the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/term">term</a> describing an approach to <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Operating%20System">Operating System</a> design by which the functionality of the system is moved out of the traditional "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>", into a set of "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s" that communicate through a "minimal" <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>, leaving as little as possible in "system space" and as much as possible in "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a> space".

<p><h3>Rationale</h3>

<p>Microkernels were invented as a reaction to traditional "monolithic" <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> design, whereby all system functionality was put in a one static program running in a special "system" mode of the processor. The rationale was that it would bring modularity in the system architecture, which would entail a cleaner system, easier to debug or dynamically modify, customizable to <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a>s' needs, and more performant.

<p><h3>Examples</h3>

<p>Perhaps the best known example of microkernel design is <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mach">Mach</a>, originally developed at CMU, and used in some free and some proprietary <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/BSD">BSD</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Unix">Unix</a> derivatives, as well as in the heart of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GNU">GNU</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/HURD">HURD</a>. Rumor had it <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microsoft%20Windows"><tt>MICROS~1</tt> Windows NT</a> would originally have been a microkernel design (that was grown into the bloated thing it is), but this has been denied by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microsoft%20Windows">NT</a> architect Dave Cutler. Other well-known microkernels include <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Chorus">Chorus</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/QNX">QNX</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/VSTa">VSTa</a>, etc. Latest evolutions in microkernel design led to things like "nano-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>" <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/L4">L4</a>, or "exokernel" <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Xok">Xok</a>, where the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> is shrunk ever more towards less functionality and less portability.

<p><h3>Opinionated History</h3>

<p>At one time in the late 1980's and early 1990's, microkernels were the craze in official academic and industrial <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> design, and anyone not submitting to the dogma was regarded as ridiculous (at least it seems to me from reading articles from <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> conferences, or the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Minix">Minix</a> vs <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a> flamefest; could people help confirm or infirm this impression of mine?). But microkernels failed to deliver their too many promises in terms of either modularity, cleanliness, ease of debugging, ease of dynamic modification, customizability, or performance. This led some microkernel people to compromise by having "single-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s" that have all the functionality, and pushing them inside <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>-space (allegedly <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microsoft%20Windows">NT</a>, hacked <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/MkLinux">MkLinux</a>), yielding a usual monolithic <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> under another name and with a contorted design. Other microkernel people instead took an even more radical view of stripping the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> from everything but the most basic system-dependent interrupt handling and messaging capabilities, and having the rest of system functionality in libraries of system or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a> code, which again is not very different from monolithic systems like <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a> that have well-delimited architecture-specific parts separated from the main body of portable code. With the rise of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a>, and the possibility to benchmark monolithic versus microkernel variants thereof, as well as the possibility to compare <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> development in various open monolithic and microkernel systems. people were forced to acknowledge the practical superiority of "monolithic" design according to all testable criteria. Nowadays, microkernel is still the "official" way to design an <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a>, although you wont be laughed at when you show your monolithic <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> anymore. But as far as we know, no one in the academic world dared raise any theoretical criticism of the very concept of microkernel.

<p><h3>Argumented Criticism</h3>

<p>As people understood that <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s only introduce (design-time and run-time) overhead without adding any functionality that couldn't be better achieved without it (for several reasons like efficiency, maintainability, modularity, etc), they tried to reduce <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> sizes as much as they could. The result is called a microkernel, which is pure overhead, with no functionality at all. There has thus been a (now waning) craze in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Operating%20System">Operating System</a> research and development to boast about using a microkernel. 

<p>I contend that microkernels are a deeply flawed idea: instead of removing the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/overhead">overhead</a>, they concentrate and multiply it. The overall space/time cost of the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> is not reduced at all, as the functionality has only been moved away from the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> into "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s"; only now there is an additional overhead in space as well as in time and as in design, to manage the information flow of system services that now needs to go from <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a> to <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> then <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> to <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>. Because of the low <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/abstraction%20level">abstraction level</a> of microkernels, lots of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> bindings must be done for "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s" that provide functionality, so nothing is gained at the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a>/<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a> interface either.

<p>As a result, microkernel-based systems are slower, bigger, harder to program, and harder to customize than monolithic <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s. The only valid rationale about them is that they encourage some modularity. However, this modularity microkernels enforce on system programmers is of a very <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> kind, which implies the overhead of (un)marshalling, as well as total lack of consistency or trust between communicating <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s. In comparison, "monolithic" systems can achieve arbitrary useful modularity with dynamically-loaded <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> code, allowing automatic enforcement of whatever consistency the system programming languages can express (for instance, strong static typing with <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a> scoping in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Modula-3">Modula-3</a>-programmed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/SPIN">SPIN</a> and <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/ML">Standard ML</a>-programmed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Fox">Fox</a>, or just weak typing with filtered global symbol matching in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%20language">C</a>-programmed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a>).

<p>Thinking that microkernels may enhance computational performance can stem but from a typical myopic analysis: indeed, at every place where functionality is implemented, things look locally simpler and more efficient. Now, if you look at the whole picture, and sum the local effects of microkernel design all over the place, it is obvious that the global effect is complexity and bloat in as much as the design was followed, i.e. at every <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a> barrier. For an analogy, take a big heavy beef, chop it into small morsels, wrap those morsels within hygienic plastic bags, and link those bags with strings; whereas each morsel is much smaller than the original beef, the end-result will be heavier than the beef by the weight of the plastic and string, in a ratio inversely proportional to the small size of chops (i.e. the more someone boasts about the local simplicity achieved by his µK, the more global complexity he has actually added w.r.t. similar design w/o µK). Microkernels only generate artificial barriers between functionalities, and any simplicity in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s is only the intrinsic simplicity of provided functionality, that is independent from the existence of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> barriers around it. Every part of a µK-based design is simpler (than a whole system), of course, because the design has butchered the system into small parts! But if one considers same-functionality overall systems, the only thing µK does is introduce stupid <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> barriers between services. The services are still there, and their intrinsic complexity isn't reduced: for every small part of a µK-based system, one could find a corresponding, smaller or equal part, in a same-functionality non-µK system, namely the one that implements the same functionality without having to marshall data to cross barriers. 

<p>Microkernels start from the (Right) idea of having modular <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/high-level">high-level</a> system design, and confuse the issue so as to end with the (Wrong) idea of its naive implementation as a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> centralized run-time <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a> manager, which constitutes a horrible <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/abstraction%20inversion">abstraction inversion</a>. So they have system programmers manually emulate an asynchronous parallel <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/actor">actor</a> model with coarse-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/grain">grain</a>ed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%20language">C</a>-programmed polling processes, instead of directly using a real fine-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/grain">grain</a>ed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/actor">actor</a> language with optimizing compiler (<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Erlang">Erlang</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Oz">Mozart/Oz</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Modula-3">Modula-3</a>, some <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrent">concurrent</a> variant of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Lisp">Lisp</a> or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/ML">ML</a> or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Haskell">Haskell</a>, etc.). The discrepancy between the model and its naive and awkward implementation induces lots of overhead, that get worked around with lots of stupid compromises, with a two-level programming system: objects are segregated into a finite set of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s and a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>, with completely different programming models for combining objects inside a same space and for combining objects not in a same space. Performance gets so bad that most "basic resources" must be statically special-cased in the "microkernel" anyway, and people group as much functionality as they can in every <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a> to not pay the price of inter-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a> communication during their interaction. Semantics also becomes very difficult to get right, since <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> interactions make a hell out of debugging the already complex <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrent">concurrent</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/actor">actor</a> model. In the end, people put the whole of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> services in a monolithic "single-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>", which completely defeats the whole purpose of a microkernel! As a result, everything gets both more complicated and slower! Of course, the very same conclusion holds for <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s in general; by pushing the idea of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s to its limits, microkernels only end up proving the whole inadequacy of it.

<p>The only possible justification for a microkernel is not technical. It's political<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/edit/political">?</a>: a microkernel is the only way to allow with any robustness the existence of black-box proprietary third-party binary <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a>s that access and provide deep system resources without anyone having to disclose source code. Microkernels are technically the worst possible organization for system code of same functionality, and the fact that the proprietary closed-source development model encourages such horrors accounts for the deep evil behind that model. It has been suggested that a psychological reason behind the abstraction inversion is that, by a misled tradition, the "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Operating%20System">Operating System</a>" community stubbornly refuses to mess with language issues (they claim "language independence"), and stick to designing system interfaces for bit-level languages; but we can also track this want of language "independence" to the political issue of proprietary software, since it is what induces the eager clustering of computing into hermetic fields where no one can modify or adapt (proprietary) code from other fields forces people into the paranoid "trust no one, never cooperate: even if you want to, you can't" behavior.

<p>Latest developments in microkernels (<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/L4">L4</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Xok">Xok</a>) amount to reducing as much as possible the semantics and overhead of the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>, and putting everything in either <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s or system libraries. The logical next step beyond these developments would be to reduce the microkernels to zero, naught, nada, and have everything in "<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a>s" that constitute the system, and are <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/high-level">high-level</a> concepts without forcibly any obvious, one-to-one direct correspondence between the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/high-level">high-level</a> compile-time <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a>s limits and <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> run-time code barriers. Depending on the point of view, this leaves us either with "monolithic" systems, or with systems without a privileged <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> at all (such as systems built atop the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Flux">Flux</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OSKit">OSKit</a>). Such is the right way, in our opinion: to provide <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/high-level">high-level</a> modular design, but without any <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> at all. <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Kernel">Kernel</a>s are but a stubborn straightforward <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> implementation of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a> management, through a centralized runtime message passing agent. Tunes will provide an optimizing compiler so that local message passing, which is only a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> model for application of a function, will be completely inlined.

<p>
<!--
Note: I have changed the style of my comments. The standard color for comments, red, is not readable for large comments.
-->
<style type="text/css">span.Mad70 {
	font-size: small;
	color : Navy;
}</style>
<h2>Response to Criticism (of exokernel in the glossary entry)</h2>

<p>(Response by <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/KC5TJA">KC5TJA</a>)

<p><span class="Mad70">[You missed completely the point, this glossary entry is not defending <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s vs microkernels!!! WE OPPOSE BOTH. We propose <strong><a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/No-Kernel">No-Kernel</a> systems</strong>. Read below. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p>First, I'd like to address the issue that an exokernel is a microkernel. IT IS NOT. Please do not confuse the microkernel and exokernel concepts.
<span class="Mad70">[<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Fare">Fare</a>, the author of this glossary entry, was not confused at all. I think he included <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/exokernel">exokernel</a>s into the concept of microkernels because the good idea (downloading application code in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> space) in this model is not pervasive, but limited to some special class of programs (application services as you noted).  -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p>The argument that microkernels contain pure overhead and contain no functionality is not only false, it's unfounded.  The author of the above cites no references to support any of his claims.
<span class="Mad70">[On the contrary, there is a proof of concept <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/No-Kernel">No-Kernel</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GO!">GO!</a>, which proves that he was right. See in particular <a href="https://web.archive.org/web/20050307161303/http://goos.sourceforge.net/performance.php">GO! OS :: PERFORMANCE RESULTS</a>. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p>On the other hand, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/AmigaOS">AmigaOS</a>'s exec.library and <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/QNX">QNX</a>'s <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> are products that are still available today (the latter example is available on a much wider scale of course), that continue to demonstrate the viability and functionality of the microkernel concept.

<p>However, the author makes a good point in the following paragraph, where he details that code requirements hasn't been reduced, but only better partitioned.  Let it be known, however, that a reduction in code footprint has NEVER been a goal of the microkernel research.  The goal was to make a more modular system, that was easier to maintain and update.

<p><span class="Mad70">[The main point of the criticism are <strong>PROTECTION BARRIERS</strong> (called rings in the Intel x86 architecture): the cost of crossing protection barriers is high, because <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Protection">Protection</a> is a stupid form of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Security">Security</a>. We propose to eliminate protection barriers. See the above mentioned <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GO!">GO!</a>, the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Lisp">Lisp</a>-based <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Genera">Genera</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Multipop">Multipop</a>, the Safe Language Kernel Project <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/SLK">SLK</a>, Kernel Mode Linux <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/KML">KML</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Language-Based%20Security">Language-Based Security</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Information-Flow%20Security">Information-Flow Security</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Capability">Capability</a> and other entries.

<p>Also you <strong>completely</strong> ignore his argument about modularity and concurrency:
<blockquote>
[..] So they have system programmers manually emulate an asynchronous parallel <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/actor">actor</a> model with coarse-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/grain">grain</a>ed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%20language">C</a>-programmed polling processes, instead of directly using a real fine-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/grain">grain</a>ed <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/actor">actor</a> language with optimizing compiler (<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Erlang">Erlang</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Oz">Mozart/Oz</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Modula-3">Modula-3</a>, some <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrent">concurrent</a> variant of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Lisp">Lisp</a> or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/ML">ML</a> or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Haskell">Haskell</a>, etc.). The discrepancy between the model and its naive and awkward implementation induces lots of overhead, that get worked around with lots of stupid compromises, with a two-level programming system: objects are segregated into a finite set of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>s and a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>, with completely different programming models for combining objects inside a same space and for combining objects not in a same space. Performance gets so bad that most "basic resources" must be statically special-cased in the "microkernel" anyway, and people group as much functionality as they can in every <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a> to not pay the price of inter-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a> communication during their interaction. Semantics also becomes very difficult to get right, since <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/low-level">low-level</a> interactions make a hell out of debugging the already complex <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrent">concurrent</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/actor">actor</a> model. In the end, people put the whole of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> services in a monolithic "single-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/server">server</a>", which completely defeats the whole purpose of a microkernel! As a result, everything gets both more complicated and slower! Of course, the very same conclusion holds for <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s in general; by pushing the idea of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s to its limits, microkernels only end up proving the whole inadequacy of it. [..]
</blockquote>
-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p>The issue of space/time efficiency is of course critical, and is perhaps the <strong>only</strong> reason microkernels have not become more popular.  <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/AmigaOS">AmigaOS</a> gets around this by message passing using only pointer swaps (blocks of memory are NOT copied in the system),
<span class="Mad70">[The original Amiga hardware was based on a Motorola 68000 CPU which <strong>misses</strong> a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/MMU">MMU</a> and then memory protection. Thus strictly speaking <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/AmigaOS">AmigaOS</a> is <strong>not</strong> a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> <strong>nor</strong> a microkernel. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>
while <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/QNX">QNX</a> gets around this by blocking the sender, allowing pages to be remapped between processes safely.  Other microkernel environments, however, COPY memory all over hell and creation, just like the Unix-based operating systems they try so hard to emulate (e.g., early versions of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mach">Mach</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/VSTa">VSTa</a>, et. al.).  Such systems are widely known in the microkernel communities as horrifically bad examples of microkernels.  Yet, these are often the most popular amongst the public, and therefore get the most attention, and negative press.

<p>The above author goes on to complain about microkernel-based systems being 
"slower, bigger, harder to program, and harder to customize than monolithic <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>s."  Let's respond to each of these in succession:

<p><ol>

<p><!-- 1 --><li>Microkernels are slower invariably when they copy memory all over the place, as discussed above.  When they don't, they're quite often <strong>faster</strong>.  Traditional monolithic kernels have to copy memory all over the place in order to get any kind of interprocess communications done, even sockets, currently the single most popular and most-often used <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/IPC">IPC</a> mechanism in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Unix">Unix</a>.

<p><span class="Mad70">[Try this search on Google and you will surprised: <a href="https://web.archive.org/web/20050307161303/http://www.google.com/search?hl=en&amp;ie=UTF-8&amp;oe=utf-8&amp;q=%22zero-copy%22">"zero-copy"</a> (you will see for example: <a href="https://web.archive.org/web/20050307161303/http://people.freebsd.org/~ken/zero_copy/">Zero copy sockets and NFS patches for FreeBSD</a>, <a href="https://web.archive.org/web/20050307161303/http://citeseer.nj.nec.com/chu96zerocopy.html">Zero-Copy TCP in Solaris</a>, <a href="https://web.archive.org/web/20050307161303/http://lists.insecure.org/linux-kernel/2000/Sep/0237.html">Linux Kernel: zero-copy TCP</a>). -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p>
<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/AmigaOS">AmigaOS</a> demonstrates the sheer speed of a microkernel-based environment: my 7MHz Amiga 500 computer, for example, though noticably slower in processing power, still has overwhelmingly superior <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a> response times than my 800MHz AMD Athlon box running Linux 2.4.18 <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>, even when running as many as 15 compute-intensive tasks.
<span class="Mad70">[I repeat myself: your Amiga 500 doesn't have an <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/MMU">MMU</a> and then it doesn't have protection barriers. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>
</li>

<p><!-- 2 --><li>Microkernel environments are bigger.  There is no evidence of this being the case.  My <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/QNX">QNX</a> RtP 6.2 installation consumes a mere 40MB of my harddrive, including the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GUI">GUI</a>.  My Linux installation consumes over 250MB for the same level of service.  And if you think <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/QNX">QNX</a> is small, my <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/AmigaOS">AmigaOS</a> installation is only 6MB, including the 512K ROM space which must necessarily be included for completeness.

<p><span class="Mad70">[You are not drawing a clear distinction between <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a> and applications: this just shows that the usual definition of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Operating%20System">Operating System</a>, when you consider level of service, is at least <em>vague</em> if not <em>meaningless</em>. Have a look at <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Fare">Fare</a> definition of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Operating%20System">Operating System</a> (common background). Also we are not defending <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a>/<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Unix">Unix</a> so this is irrelevant. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>
</li>

<p><!-- 3 --><li>Harder to program.  Every time you write a program that runs in a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GUI">GUI</a>, you're writing a microkernel "server" program.

<p><span class="Mad70">[Client/server is not the unique model of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrent">concurrent</a> programming and it is one of the more difficult.

<p>Citing from <a href="https://web.archive.org/web/20050307161303/http://www.info.ucl.ac.be/people/PVR/sigcse2003panel.pdf">The Role of Language Paradigms in Teaching Programming (.pdf)</a>, pp. 1/2:
<blockquote>
[..]
<h4>1 Joe Armstrong</h4>

<p>Programs that model or interact with the real world need to reflect the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> patterns that are observed in the real world. The real world is concurrent - and writing programs to interact with the real world should be a simply a matter of identifying the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> in the problem, identifying the message channels and mapping these 1:1 onto the code - the program then almost writes itself.

<p>Unfortunately, concurrent programming has acquired a reputation of being "difficult" and something to be avoided if possible. I believe this is a side-effect of the problems of thread programming in conventional operating systems using languages like <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Java">Java</a>, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%20Language">C</a>, or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%2B%2B">C++</a>. In a concurrent language like <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Erlang">Erlang</a>, concurrent programming becomes "easy" and becomes the natural way of solving a large class of problems.

<p>Most conventional languages that have primitives for concurrent programming provide only a thin layer to whatever mechanisms are offered by the host operating system. Thus <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Java">Java</a> uses the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> mechanisms provided by the underlying operating system and the inefficiency of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Java">Java</a> is merely a reflection of the fact that the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> mechanisms in the operating system are inefficient.

<p>I believe that <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> should be a property of the programming language and not something inherited from the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/OS">OS</a>. <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Erlang">Erlang</a> is such a language. <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Erlang">Erlang</a> processes are extremely lightweight: creating a parallel process in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Erlang">Erlang</a> is about 100 times faster than in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Java">Java</a> or <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%2B%2B">C++</a>. That's because <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> is designed into the language and has nothing to do with the host OS. Once you put <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> into the language a lot of things look very different - concurrent programing becomes easy. This is especially important in programming high-availability real-time or distributed applications where <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrency">concurrency</a> is inescapable.

<p>[..]
</blockquote>

<p>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p>The server consists of an event loop, just like any normal <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GUI">GUI</a> program does.

<p><span class="Mad70">[This is only what <strong>you</strong> know: there are other models for programming <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GUI">GUI</a>s which escapes the event-loop. See for example the paper: <a href="https://web.archive.org/web/20050307161303/http://www.cs.nyu.edu/phd_students/fuchs/gui.ps.gz">Escaping the event loop: an alternative control structure for multi-threaded GUIs (.ps.gz)</a> by Matthew Fuchs. Summarizing, on his <a href="https://web.archive.org/web/20050307161303/http://www.cs.nyu.edu/phd_students/fuchs/">home page</a>, about contributions of his PhD dissertation, he writes:

<p><blockquote>
[..]

<p>How to escape the ubiquitous <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/GUI">GUI</a> event loop and eliminate the tortured, dismembered programming style it engenders. The essential realization is that "reactive programming" with callbacks is really a twisted form of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Continuation-Passing%20Style">Continuation-Passing Style</a>, a source code transformation commonly used in compilers for <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/functional">functional</a> languages.

<p>[..]
</blockquote>

<p>See also: the paper <em>Separating Application Code from Toolkits: Eliminating the Spaghetti of Call-Backs</em> about <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Garnet">Garnet</a>, which use programming by demonstration<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/edit/programming%20by%20demonstration">?</a> and <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/constraints">constraints</a>; <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/On%20Automatic%20Interface%20Generation">On Automatic Interface Generation</a>.

<p>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span> 

<p>They even take the same form. In the case of a microkernel, they even use the same communications channels API, which significantly <strong>simplifies</strong> the program design and implementation.  I can only dream of a day when I can <strong>arbitrarily</strong> intermix GTK, <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/CORBA">CORBA</a>, and arbitrary socket API calls in my software under <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a>. <span class="Mad70">[See above discussion on <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/concurrent">concurrent</a> and other styles of programming. And, again, we are not defending <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Linux">Linux</a>/<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Unix">Unix</a> and <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%20language">C</a> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/paradigm">paradigm</a> of programming, so this is irrelevant. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span> As it is, it's patently impossible to do without dedicated, special-purpose libraries like libgnorba.
</li>

<p><!-- 4 --><li>Harder to customize.  This is a moot issue, as the microkernel has zero say about how to customize the environment.  If the software running on top of the microkernel is designed to emulate a Unix environment, it'll, well, emulate a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Unix">Unix</a> environment.  This means, editing files in the /etc directory, manipulating symlinks, et. al.  What does make things easier is the ability to run and stop "services" or daemons which implement certain functions.  For example, in <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/QNX">QNX</a>, you can run and stop <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/File%20System">filesystems</a> <span class="Mad70">[<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/File%20System">Filesystems</a>? We propose <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/orthogonal%20persistence">orthogonal persistence</a> instead. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span> at any time, change the parallel port behavior by stopping one driver and starting another, etc.  Compared to Linux's <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/module">module</a> system, it all behaves exactly the same way.  Compared to <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microsoft%20Windows">NT</a>'s "services" system, it all behaves exactly the same way.  The author above is showing a fundamental lack of understanding of how microkernel architecture works. <span class="Mad70">[No, you are showing us a fundamental lack of knowledge and/or understanding of different <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/paradigm">paradigm</a>s of programming other than that of <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/C%20language">C</a>.
<br>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>
</li>

<p></ol>

<p>The author's use of analogies above are wholly inadequate, and fail to address the core issues surrounding microkernels.  I'm still trying to figure out how beef has anything at all to do with microkernels versus monolithic kernels, in either the space or time domains.

<p>The above essay is so fundamentally flawed in his arguments that I find I can't go on thinking about it currently.  Despite being heavily biased towards the monolithic architecture, the author's intentions were clearly good.  I will openly and honestly admit that microkernels DO have some space/time trade-offs, and that the <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a>-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/kernel">kernel</a>-<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/user">user</a> transitions will consume additional overhead. <span class="Mad70">[Ah! Better late that never. -- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span> But to make a wide generalization that ALL microkernels are big, slow, hard to program, or hard to customize is just so wrong that it hardly warrents explicit justification.
<span class="Mad70">[No, we are not heavily biased towards the monolithic architecture. Please, read sufficiently this <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/index">Wiki</a> and the <a href="https://web.archive.org/web/20050307161303/http://tunes.org/">main site</a> before jumping to unfounded conclusions.
<br>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>]</span>

<p><span class="comment">[<a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a>, I saw that there were some comments about Exokernels that I thought were misleading in the glossary entry, and I asked <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/KC5TJA">KC5TJA</a>, who is much more knowledgeable about microkernels and exokernels than I am, to make the above entry to discuss this.  He did not know about TUNES's aims and thus was not speaking in that context. I think it is distasteful for you to attack him on that context, but the fault is perhaps mine as I did not pay attention to the "policy" of TUNES. At any rate, I assumed that the cliki was going to carry the same philosophy as the rest of the TUNES website - reviews of languages, OSes, methodologies, and to show both sides of the argument.
<br>p.s.: you can remove my entry if you want.
<br>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/thin">thin</a>]</span>

<p><span class="comment">[I would like to take this time to thank <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Mad70">Mad70</a> for responding. His input gives me something to think about with respect to no-kernels and other related organizational structures. I can see his points, though I do not agree with all of them, especially where he uses the Amiga itself as supporting evidence for his views on no-kernels. I will take some time to consider them.

<p>I have to admit that I have considered no-kernel-like operating environments in the past, and to this date, feel that they do represent the epitome of operating system design philosophy.  However, that merely obviates the need for protection domains.  It does not address the issue of shared resource management, which exokernels specialize in.  It is fully possible to have a no-kernel exokernel design, just as it's possible to have a microkernel running under an exokernel (or vice versa); this is the source of my contention with respect to exokernels.  The quality of being an exokernel is orthogonal to other qualities of micro/monolithic/no-kernels.

<p>However, I do not feel that it warrents further response on my part -- I think my rebuttal, and Mad70's rebuttal to mine, provides adequate material for people to learn a lot about the philosophies of the various camps.  I do feel, however, that a refactoring of this page might be in order, along perhaps with a certain "toning down" of the language to read more like written prose, and not conversation between two people.
<br>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/KC5TJA">KC5TJA</a>/6]</span>

<p><span class="Mad70">[
To <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/thin">thin</a>:  I have only responded to an attack (undeserved in my opinion) to <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Fare">Fare</a>, I have not initiated it.

<p>To <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/KC5TJA">KC5TJA</a>:
<ul>
<li>About style: well, this is a Wiki, I think that a conversational style is not so bad.
<li>About Amiga: it is a <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/no-kernel">no-kernel</a> design by accident and I have referred to it only because you have introduced it.
<li>About "toning down" of the language I don't like politically correctness at all (and I'm not fluent with English). However I have no objections to a refactoring.
</ul>
<br>-- <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/MaD70">MaD70</a>]</span>
<hr><p><b>This page is linked from: </b> <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/AmigaOS">AmigaOS</a> &nbsp; <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microkernel">Microkernel</a> &nbsp; </div><div id="footer"><form action="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/admin/search"><a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/edit/Microkernel%20Debate">Edit page</a> | <a class="internal" href="https://web.archive.org/web/20050307161303/http://cliki.tunes.org/Microkernel%20Debate?source">View source</a> | Revisions: <b title="Mon, 31 May 2004 19:31:53 GMT">1</b>  | <input name="words" size="30"><input type="submit" value="search"></form><div id="disclaimer">CTO pages can be modified by anyone at anytime.
Imagine an appropriate disclaimer. Double it. Add two.</div></body></html></div><!--
     FILE ARCHIVED ON 16:13:03 Mar 07, 2005 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 06:14:51 Dec 18, 2022.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 195.522
  exclusion.robots: 0.122
  exclusion.robots.policy: 0.111
  RedisCDXSource: 3.316
  esindex: 0.01
  LoadShardBlock: 172.219 (3)
  PetaboxLoader3.datanode: 205.51 (4)
  CDXLines.iter: 16.632 (3)
  load_resource: 99.662
  PetaboxLoader3.resolve: 41.739
-->