<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Reflection</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="/tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="reflection.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Reflection</H1
>Etymologically, reflection is first a <a class="internal" href="term.html" >term</a> about turning back the image of another object; since the phenomenon was mostly used to see oneself with mirrors (the alternate spelling reflexion is preferred for the optical phenomenon), it has come to mean applying to oneself (see <a class="internal" href="reflexive.html" >reflexive</a>). From there, it has come to mean not just to see oneself's physical image, but also to examine one's own mental state (early 17th century), and quickly applied to thinking in general (late 17th century), and has been used for well considered thought in general, although still keeping as an alternative this meaning of thinking about one's thoughts.

<p>In Computer Science, Reflection is the domain of programs that (effectively or potentially) describe and manipulate "themselves", or other related programs. This notion extends to programs the philosophical notion of Reflection of human thought that can apply to itself. The idea is not quite new, and has been used by the founding fathers of formal logic and computer science in their early theorems on the power and limits of reasoning and computation (Cantor, Gï¿½del, Turing, etc).

<p>We sometimes say reflective for potentially reflective, and likewise say reflection instead of potential reflection. In this above meaning, programming is a reflective activity, as one can program programs that program. 
A programming language or an operating system is called reflective if suited to reflective <a class="internal" href="metaprogramming.html" >metaprogramming</a>, that is, if it has provides programs some special ability to read and write themselves or other related programs. Actually, such reflection is often obtained as an interesting side effect of a more general and useful property, universality with respect to meta-programming.

<p>Computational Reflection in particular is the ability to describe inside a language the semantics of further programs. The whole point about it is that it and only it allows full control for all programs of what is to be explicit, and what is to be implicit in the semantics of these programs.

<p>We think that Reflection is just needed for computer development, and can be justified by a cost analysis that can be formalized in terms of computational complexity. If you want to develop a computer system from a supported computer system, then there must be Reflection somewhere in the system. On most current systems, that Reflection might be hidden, and might need a reboot everytime it is used (with loss of all current data, unless measures are taken manually): for instance, Linux can be developed from Linux, but you must kill all processes and reboot so as to replace a current Linux with a developed Linux.

<p>Consider then the following simple cost analysis. If <var>I</var> is the cost of all the irreflective abstraction layers between the hardware and the first reflected part <var>P</var> of the system; if <var>R</var> is the cost of all the abstraction layers that help reflect <var>P</var> into itself, then the cost of doing <var>k</var> reflective operations is greater than <code>I+k*R</code> (for compiled implementations; interpreted approaches may be exponentially worse). Current systems are such that all this often is a prohibitive cost, and as a consequence, even though all systems are somehow reflective, reflection is only marginally used. Now, the cost of <em>not</em> using computerized reflection is to do by hand what the computer would do automatically, hence having lots of automatizable tasks be done by humans, and moving to them humans the responsibility of ensuring the consistency of such a complex system. The result is a drastic decrease in productivity and reliability, and consequential limitations in achievements.

<p>The <a class="internal" href="term.html" >term</a> reflection is also used to mean the operation which inverts <a class="internal" href="reification.html" >reification</a>. In this sense the term is a synonym of deification (Wand, Friedman) and absorption (De Meuter).

<p>See our review of <a class="internal" href="methods_20of_20reflection.html" >methods of reflection</a>.

<p><ul class="links">
<li><A HREF="http://www2.parc.com/csl/groups/sda/projects/reflection96/table-of-contents.html">Reflection '96 Conference Proceedings</A
>: great material.
</ul>
<hr><p><b>Pages in this topic: </b> <a class="internal" href="reflection_20101.html" >Reflection 101</a> &nbsp; <a class="internal" href="reflection_20in_20maude.html" >Reflection in Maude</a> &nbsp; <hr><p><b>Also linked from: </b> <a class="internal" href="adaos.html" >AdaOS</a> &nbsp; <a class="internal" href="constructor_20and_20destructor.html" >Constructor and Destructor</a> &nbsp; <a class="internal" href="cybernetics.html" >Cybernetics</a> &nbsp; <a class="internal" href="inheritance.html" >Inheritance</a> &nbsp; <a class="internal" href="java.html" >Java</a> &nbsp; <a class="internal" href="maude.html" >Maude</a> &nbsp; <a class="internal" href="metaprogramming.html" >Metaprogramming</a> &nbsp; <a class="internal" href="methods_20of_20reflection.html" >Methods of Reflection</a> &nbsp; <a class="internal" href="moostrap.html" >Moostrap</a> &nbsp; <a class="internal" href="napier88.html" >Napier88</a> &nbsp; <a class="internal" href="nitrovm.html" >nitrOVM</a> &nbsp; <a class="internal" href="nuprl.html" >NuPrl</a> &nbsp; <a class="internal" href="pliant.html" >Pliant</a> &nbsp; <a class="internal" href="reflective_20tower.html" >Reflective Tower</a> &nbsp; <a class="internal" href="reflexive.html" >Reflexive</a> &nbsp; <a class="internal" href="site_20map.html" >Site Map</a> &nbsp; <a class="internal" href="static.html" >Static</a> &nbsp; <a class="internal" href="tcl.html" >TCL</a> &nbsp; <a class="internal" href="transparent.html" >Transparent</a> &nbsp; <a class="internal" href="tube.html" >Tube</a> &nbsp; </DIV></BODY></HTML>