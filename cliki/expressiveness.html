<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Expressiveness</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="/tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="expressiveness.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Expressiveness</H1
>A <a class="internal" href="term.html" >term</a> for a comparative quality of a language:

<p>A language is said to be more expressive than another one if it can express more concepts than the other. If concepts are computable functions, then there is a maximally expressive class of languages, those that are equivalent to <a class="internal" href="turing_20machine.html" >Turing machine</a>s.

<p>Now, what are concepts? If admittedly any language can be expressed inside another one, all its sentences explainable in the other, this does not mean that you can find a faithful translation of a sentence of one into a sentence of the other. Poetry, ambiguity, puns, style, are difficult to translate. So there can be more to a sentence that the informational meaning usually expected from it. While you can consider computer programs as just representations of computable functions, you can also consider criteria like computational complexity, human readability (under various circumstances), ease to modify, length, ease of connections with other concepts in other contexts, etc. There are many divergent and sometimes opposite ways to refine the concept of expressiveness. See <a class="internal" href="abstraction_20level.html" >Abstraction Level</a>.

<p>Now, a whole class of such ways is easily achieved with some Formal Logic: 
We said that structure S1 was computably more expressive than structure S2, iff there was an "representation" morphism of S2 into S1, that preserved all verifiable existential statements, which precisely means that any computable object in S2 could be computed in S1. 
Now, while existential statements represent what can be computed with the system, they surely do not suffice to express what can be computed about the system, or even simpler <em>with extensions</em> or <em>restrictions</em> to the system. So not to neglect pertinence, we must consider expressiveness relations between structures relatively to any family formularum defined in arbitrarily combined terms of quantification complexity (e.g. Sigma-n, Pi-n, Delta-n formulae), positivity constraints on some atomic relations, fixed behavior on some subset of the language, "weight" of formulae, etc, on either side of the morphism. Among these expressiveness relations, those with homogeneous symmetric constraints on the morphism induce a partial order over considered structures. 

<p>As a conclusion, we have plenty of well-defined tools that allow to build expressiveness hierarchies among programming languages. These tools seem almost never used in common courses about computer languages, which is a shame, and leads to most available language been very poorly expressive. Unhappily, we quickly see how poorly expressive are available languages relatively to what can be done, and how even among these available languages some are miserably expressive as compared to others. 

<p>Surely at the early times when logicians where the ones who studied programming languages, before computers were widely available, these expressiveness criterion appeared to them as obvious, so they did not study it a lot; the (often justified) minimalist trend among mathematicians also made them try to express the most with little expressive languages. Then, the tiny computer resources of early computers made the study of programs easy, and very expressive languages superfluous, while poorly expressive languages were much easier to implement within the limited available resources. 
All those phenomena contribute to programming language expressiveness having been neglected for long times. But if computer science is to accumulate any kind of tradition in a reliable way that lasts across generations, it can only be through expressive languages, because only they allow people to understand what people long forgotten, using technology long replaced, may have meant.

<p>See 
From our <a href="../papers/WhyNewOS/index.html">motivation article</a>, the small chapter on <a href="../papers/WhyNewOS/Part_1.html#OS Express">OS Expressiveness</a>.
The article <a href="ftp://cs.rice.edu/public/languages/scp91-felleisen.ps.gz">On the Expressive Power of Programming Languages</a> (SCP 91) by Matthias Felleisen at Rice University.
<hr><p><b>This page is linked from: </b> <a class="internal" href="abstraction_20level.html" >Abstraction Level</a> &nbsp; <a class="internal" href="language.html" >Language</a> &nbsp; <a class="internal" href="programming_20language.html" >Programming Language</a> &nbsp; <a class="internal" href="self-extensible.html" >Self-extensible</a> &nbsp; </DIV></BODY></HTML>