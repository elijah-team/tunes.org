<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : C Compiler   dlopen VM</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="http://tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="c_20compiler_20_20_20dlopen_20vm.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>C Compiler   dlopen VM</H1
><strong>Q.</strong> What is the matrix? 
<br><strong>A.</strong> The matrix is the "<a class="internal" href="c_20language.html" >C</a> compiler + dynamic linking + <code>fork()</code> + etc." <a class="internal" href="virtual_20machine.html" >Virtual Machine</a> that is spread throughout computerland.
<p>I actually think the comparison between "The Matrix" and the <a class="internal" href="c_20language.html" >C</a> compiler <a class="internal" href="virtual_20machine.html" >Virtual Machine</a> is a good one, albeit in a self-imposed dumbed down way. But don't worry the Tunes team is here to save the day...
<br>Starring <a class="internal" href="fare.html" >fare</a> as Morpheus <em>Shows <a class="internal" href="http://tunes.org/cliki/fran%E7ois-ren%E9_20rideau.html" >François</a> sitting with crossed-legs with hands pressed together praying and a feint smile with the camera swirling round him</em> and <a class="internal" href="water.html" >water</a> as Neo <em>Shows <a class="internal" href="water.html" >water</a> doing a karate move. "Yaaa!"</em>
<p>
A <a class="internal" href="virtual_20machine.html" >Virtual Machine</a> is any agreed upon standard which gives a consistent interface to using software on different hardware platforms or software in different contexts. A <a class="internal" href="virtual_20machine.html" >Virtual Machine</a> hopefully should be able to express the <a class="internal" href="semantics.html" >semantics</a> of a <a class="internal" href="computing_20system.html" >computing system</a> in a way that is capable of expressing problems and solution with <a class="internal" href="semantics.html" >semantics</a> relevant to the domain of the problem  (or actually any problem that computers might be called upon to deal with including dealing with themselves) rather than <a class="internal" href="semantics.html" >semantics</a> only relevant to technical worries. The current most universally available <a class="internal" href="vm.html" >VM</a> is the <a class="internal" href="c_20language.html" >C</a> compiler, linker and dynamic linking etc. It is poor at incremental staged evaluation. It has no support whatsoever for <a class="internal" href="migration.html" >migration</a> or <a class="internal" href="orthogonal_20persistence.html" >orthogonal persistence</a>. <span class="comment">(Note that orthogonal persistence is a kind of migration. -- <a class="internal" href="mad70.html" >MaD70</a>)</span> Lacking these it makes it so hard that it becomes unusual for anyone to want to use a computer more naturally. That is, do some work (in terms of the already established problem domain <a class="internal" href="semantics.html" >semantics</a>) then walk away, trusting in the system to handle the rest. The main fault in thinking is to, like <a class="internal" href="c_20language.html" >C</a> <a class="internal" href="vm.html" >VM</a> does, impose artificial barriers between 'programming' and 'using' computers.
<p>I don't want to write any more code in <a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a>. Did you ever get the point when you learnt <a class="internal" href="c_20language.html" >C</a>? No because there is no point. <a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a> code should be written by a computer. Its true, your instincts are right. Every time you write some <a class="internal" href="c_20language.html" >C</a> identifier down your keystrokes are forever lost in the ether. 
<p>
But for projects I am doing which have an expedient need I still need to be able to interface and use with current software written in <a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a> (which is a lot) including some commercial. Because the  "<a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a> compiler + dynamic linking + <code>fork()</code>" is the most universally available/used <a class="internal" href="virtual_20machine.html" >Virtual Machine</a> for current software. (For SGI graphics machines less and less free software supports IRIX).
<p>As well as being universally available it is the standard in terms of speed (of course). That is, for any machine with a <a class="internal" href="c_20language.html" >C</a> compiler the speed at which certain raw numeric operations are done for that machine with that <a class="internal" href="c_20language.html" >C</a> compiler is considered to be the "speed of the machine", and this is available to anyone who knows <a class="internal" href="c_20language.html" >C</a> without writing a native compiler for each individual machine. For real-time software you often need it to be running at this speed, after a possible process of deliberation (staged evaluation).
<p>But I also want a program which you don't need to quit, you just keep on adding and adding new instructions to it and changing existing ones. This is not usually the philosophy for <a class="internal" href="unix.html" >UNIX</a>/<a class="internal" href="c_20language.html" >C</a> which uses sockets or pipes and new programs communicating via them as part of the <a class="internal" href="vm.html" >VM</a> instead (which is a broken idea).
<p>So I need these things now, 'cos it would be doable and fun. Sort of like beating the <a class="internal" href="unix.html" >UNIX</a>/<a class="internal" href="c_20language.html" >C</a> system at its own game. My solution to my own problems so far... with thanks to help from <a class="internal" href="water.html" >water</a> (<A HREF="http://lists.tunes.org/archives/tunes/2003-December/">in the December 2003 Tunes mailing list</A
> <span class="comment">Not sure: "real-time constrains for tunes migration"? -- <a class="internal" href="mad70.html" >MaD70</a></span>).
<p>Use a <a class="internal" href="tunes_20hll.html" >HLL</a> with <a class="internal" href="macro.html" >macro</a>s like <a class="internal" href="lisp.html" >Lisp</a> or <a class="internal" href="scheme.html" >Scheme</a> to generate <a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a> code dynamically, with interfaces to existing <a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a> code. The <a class="internal" href="semantics.html" >semantics</a> of the <a class="internal" href="macro.html" >macro</a>s will be suitable for me (humans) to understand for whatever their problem domain (eg. certain numeric operations). 
<p>Use <a class="internal" href="c_20language.html" >C</a>/<a class="internal" href="c_2b_2b.html" >C++</a> compilers dynamically called from <a class="internal" href="lisp.html" >Lisp</a> to compile the generated code. So the <a class="internal" href="c_20language.html" >C</a> compiler is part of the <a class="internal" href="virtual_20machine.html" >Virtual Machine</a>. Run a master process which starts up other processes to run the code and co-ordinate exchanges via shared memory or sockets. It is actually possible to do dynamic code generation on <a class="internal" href="unix.html" >UNIX</a> (or <a class="internal" href="microsoft_20windows.html" >Win32</a>) providing you are willing to treat <a class="internal" href="unix.html" >UNIX</a> as a dumb slave and do the rest of the module system yourself. Using <code>dlopen()</code> or <code>dlclose()</code> on <a class="internal" href="unix.html" >UNIX</a> one can use freshly compiled code from an existing process. Could be sub-masters etc.
<span class="comment">MACISTE does that, and so does <a class="internal" href="goo.html" >Goo</a>. Well, to a point; no management of subprocesses fault containment for untrusted libraries. -- <a class="internal" href="fare.html" >Faré</a></span>
<p>
The point of this is to act like a glue between various components such as scene graph, Oracle database, specifically for me for virtual reality apps.
<p>Seeing as how universal the <a class="internal" href="c_20language.html" >C</a> <a class="internal" href="vm.html" >VM</a> is, I surprisingly haven't been able to find much stuff on generating <a class="internal" href="c_20language.html" >C</a> code from a customizable language such as <a class="internal" href="lisp.html" >Lisp</a> (I don't mean compiling <a class="internal" href="lisp.html" >Lisp</a> to <a class="internal" href="c_20language.html" >C</a> like ECL does, I mean a library to generate <a class="internal" href="c_20language.html" >C</a>). But that's ok I'll start off with specific stuff that I need in fact I might start with the dynamic linking part and just have <a class="internal" href="c_20language.html" >C</a> embbeded in <a class="internal" href="lisp.html" >Lisp</a> code.
<p>-- <a class="internal" href="codeburnt.html" >codeburnt</a>
<p><span class="comment">Keep us informed about your progress on this front. -- <a class="internal" href="mad70.html" >MaD70</a></span>
<p><A HREF="http://www.pocketpcthoughts.com/forums/viewtopic.php?t=24235">Further discussions on pocketpc thoughts</A
>
<hr><p><b>This page is linked from: </b> <a class="internal" href="virtual_20machines.html" >Virtual Machines</a> &nbsp; </DIV></BODY></HTML>
