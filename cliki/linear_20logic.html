<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Linear Logic</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="/tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="linear_20logic.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Linear Logic</H1
>Linear Logic, which started as a theoretical endeavor in proof theory, is now a theme of study of its own. It is the <a class="internal" href="term.html" >term</a> for the study of generalized <a class="internal" href="linear_20algebra.html" >linear algebra</a>s over computational term algebras. It has ubiquitous applications in computer science: in proof theory, rewrite logic, compiler optimization, <a class="internal" href="memory.html" >memory</a> management, concurrency control, security assessment, etc.

<p>Expressing computations with linear terms (with logical disjunction as the sum operator, and computational constructors as the product operators) is a very convenient and elegant way to cleanly express the semantics of objects taking into account resources (such as memory, time, etc) whose physical unicity prevents multiple instances of the objects from existing at the same time: the state of the system will be represented by terms that are linear in each of the (states of) the unique objects. The sums indicate that several possibilities are open as to the state of the system, upon which a choice may be made, depending on the place in space, the moment in time, and the fulfillment of various logical hypotheses; the products indicate combination of simpler resources into more elaborate states. Linear transformations are then computational operations that preserve the fact that at any time, each unique object has just one state, even though it may still be to decide which state this is among many. Stateful programming is precisely modeled by considering state transitions as pure linear transformers of the state, with linear variables corresponding to state and resources; in such context, immediate recycling optimization for the new value of a "same" variable corresponds to the physical address of the variable not moving with time.

<p>Linearity is a very useful tool in a wide range of situations, for a linear resource, one referenced at precisely one place and used just once, can be recycled immediately after its first and unique use, in real-time. It can be used in concurrent and distributed systems, to manage coherent access to a resource without expensive locking. It can be used in memory management to avoid costly garbage collection algorithms. It can be used in modular programming to assert security properties and negotiate resource responsibility. It can be used in real-time programming to assert real-time response of the system. It can be used in all cases for various compiler optimizations.

<p>Since linearity is a initially a syntactic property of programs, it can be easily checked by compilers as part of type-checking. It can be made user-visible as in <a class="internal" href="clean.html" >Clean</a>, or in <a class="internal" href="haskell.html" >Haskell</a> with <a class="internal" href="monad.html" >monad</a>s; or it can be handled behind the scenes by the compiler, in a way that can take advantage of automatic optimizations independent from the user. But although user-invisibility may save the user from unnecessary choices (or protect him from harmful ones), it also prevents him from communicating deliberate choices, and thus the compiler might not be able to optimize out of inferred information for objects exported to separate compilation, dynamic linking, or dynamic code modification.

<p>In Tunes, we believe that linear constraints should be explicitly visible to users who care, because of their importance in distributed, concurrent and modular systems.

<p>See: user-visible typing of programs with linear types: the programming languages <a class="internal" href="clean.html" >Clean</a>, <a class="internal" href="haskell.html" >Haskell</a>, and <a class="internal" href="mercury.html" >Mercury</a>; linearity in resource management and compiler optimization: articles by <a class="internal" href="henry_20baker.html" >Henry Baker</a>; linearity in <a class="internal" href="distributed.html" >distributed</a> programming: the PhD thesis of <a class="internal" href="alan_20bawden.html" >Alan Bawden</a>, works by <a class="internal" href="a._20yonezawa.html" >A. Yonezawa</a>'s team; linearity in compiler theory: articles by <a class="internal" href="philip_20wadler.html" >Philip Wadler</a>, lots of interpretation-based analyses done in optimizing compilers; the concept of linearity in rewrite systems: any basic course on <a class="internal" href="rewrite.html" >rewrite</a> logic; etc.<hr><p><b>This page is linked from: </b> <a class="internal" href="aardappel.html" >Aardappel</a> &nbsp; <a class="internal" href="clean.html" >Clean</a> &nbsp; <a class="internal" href="constructor_20and_20destructor.html" >Constructor and Destructor</a> &nbsp; <a class="internal" href="continuation.html" >Continuation</a> &nbsp; <a class="internal" href="forth.html" >Forth</a> &nbsp; <a class="internal" href="linear_20graph_20reduction.html" >Linear Graph Reduction</a> &nbsp; <a class="internal" href="linear_20logic_20comments.html" >Linear Logic Comments</a> &nbsp; <a class="internal" href="linearity_20101.html" >Linearity 101</a> &nbsp; <a class="internal" href="referential_20transparency_20and_20state.html" >Referential Transparency and State</a> &nbsp; <a class="internal" href="sheep.html" >Sheep</a> &nbsp; <a class="internal" href="vault.html" >Vault</a> &nbsp; </DIV></BODY></HTML>