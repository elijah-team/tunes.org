<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Thread</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="http://tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="thread.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Thread</H1
>In Tunes, the <a class="internal" href="term.html" >term</a> for <em>any</em> kind of <a class="internal" href="object.html" >object</a> that can be considered semantically as a logical unit of execution, from a light-weight <a class="internal" href="continuation.html" >continuation</a> being evaluated to a number of coarse-<a class="internal" href="grain.html" >grain</a>ed <a class="internal" href="unix.html" >unix</a>ish <a class="internal" href="process.html" >process</a>es, including interrupt handling code, etc. Threads can be dynamically decomposed in sequential or parallel subthreads, that may interact more or less with each other, until the hardware level is reached, which constitutes the ultimately atomic threads. However, the system only consider as a thread what was interfaced to it as such, which sure is not the case of every single instruction, in the same way as it accepts any <a class="internal" href="object.html" >object</a> from the world to a single bit as an <a class="internal" href="object.html" >object</a>, but not every single bit is fully interfaced as a first-class system entity.
<p>The standard model for computing is to consider a computer as a <a class="internal" href="sequential_20machine.html" >sequential machine</a> (which single-<a class="internal" href="cpu.html" >CPU</a> computers actually are). Parallelism is then modeled (and simulated/faked inside sequential computers) as multiple sequential machines interacting; each virtual sequential machine is named a thread of execution.
<p>In traditional <a class="internal" href="os.html" >OS</a>es, the <a class="internal" href="term.html" >term</a> <em>thread</em> denotes a light, user-rewritten version of the <a class="internal" href="os.html" >OS</a>'s <a class="internal" href="process.html" >process</a>es.
<p>When programmers see that their <a class="internal" href="os.html" >OS</a>'s <a class="internal" href="process.html" >process</a> concept is too bulky, that their <a class="internal" href="os.html" >OS</a>'s scheduler introduces too much <a class="internal" href="overhead.html" >overhead</a>, that they need a potentially high number of asynchronous procedures that share data quickly and don't overflow the "process table" or do numerous system calls, they use thread packages to cope with it. Thread packages are insecure dirty (but sometimes necessary) hacks.
<hr><p><b>This page is linked from: </b> <a class="internal" href="actor.html" >Actor</a> &nbsp; <a class="internal" href="highly_20concurrent.html" >highly concurrent</a> &nbsp; </DIV></BODY></HTML>