<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Assembly</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="http://tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="assembly.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Assembly</H1
>At the heart of computer is traditionally a piece of electronic circuitry that executes instructions in sequence, as fetched from memory where they are encoded in bit patterns. Assembly language (or just assembler) is a <a class="internal" href="term.html" >term</a> for the human-readable description of a computer's instruction set, that can then be straightforwardly translated into bit patterns, which process is called assembling (hence assembly language), and can be done manually or by a program called an assembler. 
<p>Assembly is generally the most direct way used by humans to program a computer, and is the only tool that ultimately (or rather initially) allows complete control over what the computer does. This is why it is to use for the founding items of an operating system, and critical parts of programs. Moreover, even when not strictly necessary, the use of assembly can yield substantial performance with respect to time, memory, or other resource usage, that will turn otherwise sluggish or obsolete computers into useful hardware, and make the most out of powerful hardware, thus saving incredible amounts of human work, and enabling useful human activity. Therefore, it is necessary that in any <a class="internal" href="operating_20system.html" >operating system</a>, the use of assembly, and its interfacing with the rest of the system be made possible and as easy as possible.
<p>However, assembly programming is quite unportable, as different computers have different instruction sets, and even computers with common or similar instruction sets have different performance constraints. It is also the most <a class="internal" href="low-level.html" >low-level</a> kind of programming, too, with all the according disadvantages (lack of evolutivity, maintainability, scalability, difficulty to read, write and check, and more generally, lack of adaptation to the way humans express problems). Actually, in everyday life, using assembly is the typical kind of long stubborn hassle that humans can be relieved of by automatic programs called compilers.
<p>For these reasons, once a system is developed enough, manual direct assembly programming eventually proves a quite suboptimal tool for most task, and people will tend to rather use a <a class="internal" href="high-level.html" >high-level</a> language, in which they can express the problems they tackle independently from the particular constraints of the internal representation used. But there is no reason (on the contrary) why all the expressive power of assembly be dropped, as is done in nowadays operating systems. Sure, the use of assembly should be automated, through the use of compilers, but the assembly code generation done by these compilers should be completely controllable and programmable by the user, which is meta-programmed code generation. 
<p>We, at the TUNES project, believe that such <a class="internal" href="metaprogramming.html" >metaprogramming</a> is the most useful way to go, and that it will thus eventually overcome and succeed.
<p><ul class="links">
  <li><A HREF="http://webster.cs.ucr.edu/">The Art of Assembly Language Programming</A
> x86 assembly programming, by Randall Hyde.</li>
  <li><A HREF="http://linuxassembly.org/">Linux Assembly</A
>.</li>
  <li><A HREF="http://linuxassembly.org/howto.html">Linux Assembly HOWTO</A
> (<a class="internal" href="fare.html" >Fare</a> is one of the copyright holders).</li>
  <li><A HREF="http://www-cs-faculty.stanford.edu/~knuth/mmix.html">MMIX Computer</A
> A theoretical microprocessor with a portable interpreter and good documentation.  It's a great way to learn assembly.</li>
<p></ul><hr><p><b>Pages in this topic: </b> <a class="internal" href="new_20jersey_20machine_20code_20toolkit.html" >New Jersey Machine Code Toolkit</a> &nbsp; <a class="internal" href="tal.html" >TAL</a> &nbsp; <hr><p><b>Also linked from: </b> <a class="internal" href="agnix.html" >Agnix</a> &nbsp; <a class="internal" href="c--.html" >C--</a> &nbsp; <a class="internal" href="charles_20childers.html" >Charles Childers</a> &nbsp; <a class="internal" href="continuation-passing_20style.html" >Continuation-Passing Style</a> &nbsp; <a class="internal" href="derive.html" >DERIVE</a> &nbsp; <a class="internal" href="foreign_20function_20interface.html" >Foreign Function Interface</a> &nbsp; <a class="internal" href="forth.html" >Forth</a> &nbsp; <a class="internal" href="forth_20oses.html" >Forth OSes</a> &nbsp; <a class="internal" href="hop.html" >hOp</a> &nbsp; <a class="internal" href="libero.html" >Libero</a> &nbsp; <a class="internal" href="menuetos.html" >MenuetOS</a> &nbsp; <a class="internal" href="meta-system_20transition.html" >Meta-System Transition</a> &nbsp; <a class="internal" href="nasm.html" >NASM</a> &nbsp; <a class="internal" href="ocaml.html" >OCAML</a> &nbsp; <a class="internal" href="python.html" >Python</a> &nbsp; <a class="internal" href="shawnos.html" >ShawnOS</a> &nbsp; <a class="internal" href="synthesis.html" >Synthesis</a> &nbsp; <a class="internal" href="unununium.html" >Unununium</a> &nbsp; <a class="internal" href="v2_os.html" >V2_OS</a> &nbsp; </DIV></BODY></HTML>