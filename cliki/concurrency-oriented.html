<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Concurrency-Oriented</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="http://tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="concurrency-oriented.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Concurrency-Oriented</H1
>A <a class="internal" href="term.html" >term</a> describing a <a class="internal" href="programming_20language.html" >programming language</a> <a class="internal" href="paradigm.html" >paradigm</a> where independent parts of the problem can be represented as independent computations. This requires that concurrency should be easy, with language support, that to some level concurrency be transparent, and that the implementation should ensure it is cheap.
<p>The two major inspirations for this term are <a class="internal" href="mozart_2foz.html" >Mozart/Oz</a>, which has declarative concurrency, and <a class="internal" href="erlang.html" >Erlang</a>, which has message-passing <a class="internal" href="concurrency.html" >concurrency</a> (also referred to as the <a class="internal" href="actor.html" >Actor</a> model), but any language marked here as <a class="internal" href="concurrent.html" >concurrent</a> is similar to one of these two.
<p>The basic properties seem to be (as outlined by Joe Armstrong - see his papers below):
<ol>
<li>Concurrency-Oriented languages must support processes. A process can be thought of as a self-contained virtual machine.
<li>Several processes operating on the same machine must be strongly isolated.  A fault in one process should not adversely affect another process, unless such interaction is explicitly programmed. Two processes operating on the same machine must be as independent as if they ran on physically separated machines.
<li>Each process must be identified by a unique unforgeable identifier.
<li>There should be no shared state between processes.  Processes interact by sending messages.  If you know the identifier of a process then you can send a message to the process.
<li>Location transparency: you send a message to a process the same way no matter what machine it's on, you don't <em>have</em> to care about locations.
<li>Message passing is assumed to be unreliable with no guarantee of delivery:
<ul>
  <li>Message passing is atomic: a message is either delivered in its entirety or not at all.
  <li>Message passing between a pair of processes is ordered [If P1 sends X then Y to P2, P2 will receive X before Y].
  <li>Messages should not refer to mutable data. [Reason: if sender crashes or laters data, what happens to message?]
</ul>
<li>It should be possible for one process to detect failure in another process.  We should also know the reason for faiure.
</ol>
<p>He also outlines some essential requirements:
<dl>
<dt>Concurrency</dt><dd>The computational effort needed to create or destroy a concurrent process should be very small, and there should be no penalty for creating large numbers (explained elsewhere as hundreds of thousands) of concurrent processes.</dd>
<dt>Error encapsulation</dt><dd>Errors occurring in one process must not be able to damage other processes in the system.</dd>
<dt>Fault detection</dt><dd>Exceptions should be detectable and handlable both locally, in the process where the exception occurred, and remotely - in a non-local process.</dd>
<dt>Fault identification</dt><dd>We should be able to identify why an exception occurred.</dd>
<dt>Code upgrade</dt><dd>There should exist mechanisms to change code as it is executing and without stopping the system.</dd>
<dt>Persistence</dt><dd>We need to store data in a manner which survives a system crash.  More precisely, we need to store <em>selected</em> data in a manner which survives a system crash.</dd>
</dl>
<p><ul class="links">
<li>Various papers by <A HREF="http://www.sics.se/~joe/">Joe Armstrong</A
> who developed the idea.
<li>A <A HREF="http://lambda-the-ultimate.org/classic/message9289.html">discussion on it</A
> at <a class="internal" href="ltu.html" >LtU</a>.
</ul>
<hr><p><b>This page is linked from: </b> <a class="internal" href="actor.html" >Actor</a> &nbsp; </DIV></BODY></HTML>